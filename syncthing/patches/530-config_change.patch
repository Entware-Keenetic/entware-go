gccgo compiled binaries do not save changed configuartion in many cases,
they end up web connection with "WARNING: API: use of closed network connection".
Strange but this bug is not always reproducable - sometimes everything works as expexted!
The patch forces saving config and reports user to manually restart syncthing.
--- a/src/github.com/syncthing/syncthing/cmd/syncthing/gui.go
+++ b/src/github.com/syncthing/syncthing/cmd/syncthing/gui.go
@@ -386,33 +386,6 @@
 }
 
 func (s *apiService) CommitConfiguration(from, to config.Configuration) bool {
-	if to.GUI == from.GUI {
-		return true
-	}
-
-	// Order here is important. We must close the listener to stop Serve(). We
-	// must create a new listener before Serve() starts again. We can't create
-	// a new listener on the same port before the previous listener is closed.
-	// To assist in this little dance the Serve() method will wait for a
-	// signal on the configChanged channel after the listener has closed.
-
-	s.listenerMut.Lock()
-	defer s.listenerMut.Unlock()
-
-	s.listener.Close()
-
-	var err error
-	s.listener, err = s.getListener(to.GUI)
-	if err != nil {
-		// Ideally this should be a verification error, but we check it by
-		// creating a new listener which requires shutting down the previous
-		// one first, which is too destructive for the VerifyConfiguration
-		// method.
-		return false
-	}
-
-	s.configChanged <- struct{}{}
-
 	return true
 }
 
--- a/src/github.com/syncthing/syncthing/lib/connections/service.go
+++ b/src/github.com/syncthing/syncthing/lib/connections/service.go
@@ -414,70 +414,7 @@
 }
 
 func (s *Service) CommitConfiguration(from, to config.Configuration) bool {
-	// We require a restart if a device as been removed.
-
-	restart := false
-
-	newDevices := make(map[protocol.DeviceID]bool, len(to.Devices))
-	for _, dev := range to.Devices {
-		newDevices[dev.DeviceID] = true
-	}
-
-	for _, dev := range from.Devices {
-		if !newDevices[dev.DeviceID] {
-			restart = true
-		}
-	}
-
-	s.listenersMut.Lock()
-	seen := make(map[string]struct{})
-	for _, addr := range config.Wrap("", to).ListenAddresses() {
-		if _, ok := s.listeners[addr]; ok {
-			seen[addr] = struct{}{}
-			continue
-		}
-
-		uri, err := url.Parse(addr)
-		if err != nil {
-			l.Infof("Listener for %s: %v", addr, err)
-			continue
-		}
-
-		factory, err := s.getListenerFactory(to, uri)
-		if err == errDisabled {
-			l.Debugln("Listener for", uri, "is disabled")
-			continue
-		}
-		if err != nil {
-			l.Infof("Listener for %v: %v", uri, err)
-			continue
-		}
-
-		s.createListener(factory, uri)
-		seen[addr] = struct{}{}
-	}
-
-	for addr, listener := range s.listeners {
-		if _, ok := seen[addr]; !ok || !listener.Factory().Enabled(to) {
-			l.Debugln("Stopping listener", addr)
-			s.Remove(s.listenerTokens[addr])
-			delete(s.listenerTokens, addr)
-			delete(s.listeners, addr)
-		}
-	}
-	s.listenersMut.Unlock()
-
-	if to.Options.NATEnabled && s.natServiceToken == nil {
-		l.Debugln("Starting NAT service")
-		token := s.Add(s.natService)
-		s.natServiceToken = &token
-	} else if !to.Options.NATEnabled && s.natServiceToken != nil {
-		l.Debugln("Stopping NAT service")
-		s.Remove(*s.natServiceToken)
-		s.natServiceToken = nil
-	}
-
-	return !restart
+	return false
 }
 
 func (s *Service) AllAddresses() []string {
